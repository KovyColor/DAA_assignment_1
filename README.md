# Assignment 1 â€“ Divide & Conquer Algorithms

## ğŸ¯ Learning Goals
- Implement classic divide-and-conquer algorithms with safe recursion patterns.  
- Analyze running-time recurrences using the Master Theorem and Akraâ€“Bazzi intuition.  
- Collect metrics (execution time, recursion depth, comparisons/allocations) and compare with theoretical predictions.  

---

## ğŸ›  Implemented Algorithms
1. **MergeSort**  
   - Uses reusable buffer for merging.  
   - Falls back to InsertionSort for small subarrays (cutoff optimization).  
   - Recurrence: T(n) = 2T(n/2) + Î˜(n) â†’ Î˜(n log n).  

2. **QuickSort (robust)**  
   - Randomized pivot selection.  
   - Recurses only on the smaller side, larger one is handled iteratively (bounded stack O(log n)).  
   - Recurrence: T(n) = T(k) + T(n-k-1) + Î˜(n) â†’ Î˜(n log n) average, Î˜(nÂ²) worst case.  

3. **Deterministic Select (Median-of-Medians)**  
   - Groups of 5, pivot = median of medians.  
   - Recurses into the smaller partition only.  
   - Recurrence: T(n) = T(n/5) + T(7n/10) + Î˜(n) â†’ Î˜(n).  

4. **Closest Pair of Points (2D)**  
   - Divide by x-coordinate, recursive split.  
   - â€œStripâ€ check using y-order, scanning at most 7â€“8 neighbors.  
   - Recurrence: T(n) = 2T(n/2) + Î˜(n) â†’ Î˜(n log n).  

---

## ğŸ“Š Metrics & Results
During experiments the following metrics were collected:  
- Execution time (ns â†’ ms).  
- Maximum recursion depth.  
- Number of comparisons.  
- Approximate memory allocations.  

Example CSV output (generated by the program):  

algorithm,n,elapsed_ns,max_depth,comparisons,allocations
MergeSort,10000,12345678,18,75000,40000
QuickSort,10000,9876543,20,68000,0
Select,10000,5432100,12,51000,0
ClosestPair,5000,7654321,16,90000,0


### Plots
*(insert actual graphs here, generated from `metrics.csv`)*  

- **Time vs Input Size (n)**  
  ![time graph](plots/time_vs_n.png)  

- **Recursion Depth vs Input Size (n)**  
  ![depth graph](plots/depth_vs_n.png)  

---

## ğŸ“Œ Observations
- **MergeSort** shows stable O(n log n) growth; cutoff helps small cases.  
- **QuickSort** is fast on random data, recursion depth â‰ˆ 2 logâ‚‚n as expected.  
- **Deterministic Select** confirms O(n), but slower than QuickSelect due to higher constants.  
- **Closest Pair** matches O(n log n); strip step is only noticeable for large inputs.  
- Minor deviations are explained by JVM effects (GC, caching).  

---

## ğŸ§ª Testing
- Sorting algorithms tested on random and adversarial arrays.  
- Select verified against `Arrays.sort(a)[k]` (100 random trials).  
- Closest Pair validated against brute-force O(nÂ²) on small inputs (n â‰¤ 2000).  

---

## ğŸŒ³ GitHub Workflow
- **Main branch**: `main` (stable releases: v0.1, v1.0).  
- **Feature branches**:  
  - `feature/mergesort`  
  - `feature/quicksort`  
  - `feature/select`  
  - `feature/closest`  
  - `feature/metrics`  

**Commit storyline example:**  
- `init: maven, junit5, ci, readme`  
- `feat(metrics): counters, depth tracker, CSV writer`  
- `feat(mergesort): baseline + reuse buffer + cutoff + tests`  
- `feat(quicksort): smaller-first recursion, randomized pivot + tests`  
- `refactor(util): partition, swap, shuffle, guards`  
- `feat(select): deterministic select (MoM5) + tests`  
- `feat(closest): divide-and-conquer implementation + tests`  
- `feat(cli): parse args, run algos, emit CSV`  
- `bench(jmh): harness for select vs sort`  
- `docs(report): master cases & AB intuition, initial plots`  
- `fix: edge cases (duplicates, tiny arrays)`  
- `release: v1.0`  

---

## ğŸš€ How to Run
In IntelliJ IDEA:  
1. Open **Run â†’ Edit Configurationsâ€¦**.  
2. Set `assignment1.Main` as the main class.  
3. Add program arguments:  

Examples:  
mergesort 10000 metrics.csv
quicksort 10000 metrics.csv
select 10000 metrics.csv
closest 5000 metrics.csv


The program will print metrics to console and append them to `metrics.csv`.  
