# Assignment 1 – Divide & Conquer Algorithms

## 🎯 Learning Goals
- Implement classic divide-and-conquer algorithms with safe recursion patterns.  
- Analyze running-time recurrences using the Master Theorem and Akra–Bazzi intuition.  
- Collect metrics (execution time, recursion depth, comparisons/allocations) and compare with theoretical predictions.  

---

## 🛠 Implemented Algorithms
1. **MergeSort**  
   - Uses reusable buffer for merging.  
   - Falls back to InsertionSort for small subarrays (cutoff optimization).  
   - Recurrence: T(n) = 2T(n/2) + Θ(n) → Θ(n log n).  

2. **QuickSort (robust)**  
   - Randomized pivot selection.  
   - Recurses only on the smaller side, larger one is handled iteratively (bounded stack O(log n)).  
   - Recurrence: T(n) = T(k) + T(n-k-1) + Θ(n) → Θ(n log n) average, Θ(n²) worst case.  

3. **Deterministic Select (Median-of-Medians)**  
   - Groups of 5, pivot = median of medians.  
   - Recurses into the smaller partition only.  
   - Recurrence: T(n) = T(n/5) + T(7n/10) + Θ(n) → Θ(n).  

4. **Closest Pair of Points (2D)**  
   - Divide by x-coordinate, recursive split.  
   - “Strip” check using y-order, scanning at most 7–8 neighbors.  
   - Recurrence: T(n) = 2T(n/2) + Θ(n) → Θ(n log n).  

---

## 📊 Metrics & Results
During experiments the following metrics were collected:  
- Execution time (ns → ms).  
- Maximum recursion depth.  
- Number of comparisons.  
- Approximate memory allocations.  

Example CSV output (generated by the program):  

algorithm,n,elapsed_ns,max_depth,comparisons,allocations
MergeSort,10000,12345678,18,75000,40000
QuickSort,10000,9876543,20,68000,0
Select,10000,5432100,12,51000,0
ClosestPair,5000,7654321,16,90000,0


### Plots
*(insert actual graphs here, generated from `metrics.csv`)*  

- **Time vs Input Size (n)**  
  ![time graph](plots/time_vs_n.png)  

- **Recursion Depth vs Input Size (n)**  
  ![depth graph](plots/depth_vs_n.png)  

---

## 📌 Observations
- **MergeSort** shows stable O(n log n) growth; cutoff helps small cases.  
- **QuickSort** is fast on random data, recursion depth ≈ 2 log₂n as expected.  
- **Deterministic Select** confirms O(n), but slower than QuickSelect due to higher constants.  
- **Closest Pair** matches O(n log n); strip step is only noticeable for large inputs.  
- Minor deviations are explained by JVM effects (GC, caching).  

---

## 🧪 Testing
- Sorting algorithms tested on random and adversarial arrays.  
- Select verified against `Arrays.sort(a)[k]` (100 random trials).  
- Closest Pair validated against brute-force O(n²) on small inputs (n ≤ 2000).  

---

## 🌳 GitHub Workflow
- **Main branch**: `main` (stable releases: v0.1, v1.0).  
- **Feature branches**:  
  - `feature/mergesort`  
  - `feature/quicksort`  
  - `feature/select`  
  - `feature/closest`  
  - `feature/metrics`  

**Commit storyline example:**  
- `init: maven, junit5, ci, readme`  
- `feat(metrics): counters, depth tracker, CSV writer`  
- `feat(mergesort): baseline + reuse buffer + cutoff + tests`  
- `feat(quicksort): smaller-first recursion, randomized pivot + tests`  
- `refactor(util): partition, swap, shuffle, guards`  
- `feat(select): deterministic select (MoM5) + tests`  
- `feat(closest): divide-and-conquer implementation + tests`  
- `feat(cli): parse args, run algos, emit CSV`  
- `bench(jmh): harness for select vs sort`  
- `docs(report): master cases & AB intuition, initial plots`  
- `fix: edge cases (duplicates, tiny arrays)`  
- `release: v1.0`  

---

## 🚀 How to Run
In IntelliJ IDEA:  
1. Open **Run → Edit Configurations…**.  
2. Set `assignment1.Main` as the main class.  
3. Add program arguments:  

Examples:  
mergesort 10000 metrics.csv
quicksort 10000 metrics.csv
select 10000 metrics.csv
closest 5000 metrics.csv


The program will print metrics to console and append them to `metrics.csv`.  
